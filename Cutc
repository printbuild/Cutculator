pip freeze > requirements.txt

!pip install ezdxf
!pip install dxfgrabber
!pip install aiogram ezdxf




import asyncio
import logging
import ezdxf
import math
from ezdxf.math import Vec3
from aiogram import Bot, Dispatcher, types
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.filters import Command
import os

TOKEN = "7762345234:AAEXGt5um0ffbpXMcs-q40QEMXdJhGcvDos"

logging.basicConfig(level=logging.INFO)

bot = Bot(token=TOKEN)
dp = Dispatcher()

# –•—Ä–∞–Ω–∏–ª–∏—â–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
registered_users = {}

# –°–ø–∏—Å–æ–∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤
ADMIN_IDS = [610537237]  # –£–∫–∞–∂–∏ –∑–¥–µ—Å—å ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤

keyboard = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üî¢ –ù–∞—á–∞—Ç—å —Ä–∞—Å—á—ë—Ç")],
        [KeyboardButton(text="üìù –û—Å—Ç–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤")]  # –ö–Ω–æ–ø–∫–∞ –¥–ª—è –æ—Ç–∑—ã–≤–∞
    ],
    resize_keyboard=True
)

coefficients = {}
cutting_cost = None

@dp.message(Command("start"))
async def start_command(message: types.Message):
    user_id = message.from_user.id
    if user_id not in registered_users:
        registered_users[user_id] = {"registered": False}
        await message.answer("–ü—Ä–∏–≤–µ—Ç!üëã –î–∞–≤–∞–π —Å–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Ç–µ–±—è. –ù–∞–ø–∏—à–∏ —Å–≤–æ—é –ø–æ—á—Ç—É")
    else:
        await message.answer("–ü—Ä–∏–≤–µ—Ç!üëã –≠—Ç–æ –ö–∞—Ç–∫—É–ª—è—Ç–æ—Ä üßÆ - –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞—Å—á–µ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç–∏ —Ä–µ–∑–∞ –≤–∞—à–∏—Ö –∏–∑–¥–µ–ª–∏–π –∏–∑ —Ñ–∞–Ω–µ—Ä—ã, –º–µ—Ç–∞–ª–ª–∞ –∏ –¥—Ä—É–≥–∏—Ö –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤.", reply_markup=keyboard)

@dp.message(Command("users"))
async def list_users(message: types.Message):
    if message.from_user.id not in ADMIN_IDS:
        await message.answer("‚õî –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
        return

    if not registered_users:
        await message.answer("üìã –°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø—É—Å—Ç.")
        return

    user_list = "\n".join([f"üë§ ID: {user_id}, –ü–æ—á—Ç–∞: {data['mail']}"
                            for user_id, data in registered_users.items() if data["registered"]])

    await message.answer(f"üìã *–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:*\n{user_list}", parse_mode="Markdown")

@dp.message(lambda message: message.from_user.id in registered_users and not registered_users[message.from_user.id]["registered"])
async def register_user(message: types.Message):
    user_id = message.from_user.id
    try:
        mail_user = int(message.text)
        registered_users[user_id] = {"registered": True, "mail": mail_user}
        await message.answer("‚úÖ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –¢–µ–ø–µ—Ä—å —Ç—ã –º–æ–∂–µ—à—å –Ω–∞—á–∞—Ç—å —Ä–∞—Å—á–µ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç–∏ —Ä–µ–∑–∞.", reply_markup=keyboard)
    except ValueError:
        await message.answer("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ —á–∏—Å–ª–æ - —Å—Ä–µ–¥–Ω–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–∫–∞–∑–æ–≤ –≤ –º–µ—Å—è—Ü.")

@dp.message(lambda message: message.text == "üî¢ –ù–∞—á–∞—Ç—å —Ä–∞—Å—á—ë—Ç")
async def input_coefficients(message: types.Message):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –¥–ª—è –ª–∏–Ω–∏–π, –ø–æ–ª–∏–ª–∏–Ω–∏–π, –¥—É–≥, –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–µ–π –∏ —Å–ø–ª–∞–π–Ω–æ–≤ —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª")

@dp.message(lambda message: message.text and len(message.text.split()) == 5)
async def set_coefficients(message: types.Message):
    global coefficients
    try:
        values = list(map(float, message.text.split()))
        coefficients = {"LINE": values[0], "POLYLINE": values[1], "ARC": values[2], "CIRCLE": values[3], "SPLINE": values[4]}
        await message.answer("‚úÖ –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã. –¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ —Å—Ç–æ–∏–º–æ—Å—Ç—å —Ä–µ–∑–∞ (–∑–∞ –º–º).")
    except ValueError:
        await message.answer("‚ùå –û—à–∏–±–∫–∞! –í–≤–µ–¥–∏—Ç–µ 5 —á–∏—Å–µ–ª —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª.")

@dp.message(lambda message: message.text and message.text.replace('.', '', 1).isdigit())
async def set_cutting_cost(message: types.Message):
    global cutting_cost
    try:
        cutting_cost = float(message.text)
        await message.answer("‚úÖ –°—Ç–æ–∏–º–æ—Å—Ç—å —Ä–µ–∑–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞. –¢–µ–ø–µ—Ä—å –∑–∞–≥—Ä—É–∑–∏—Ç–µ DXF-—Ñ–∞–π–ª.")
    except ValueError:
        await message.answer("‚ùå –û—à–∏–±–∫–∞! –í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ.")

@dp.message(lambda message: message.document)
async def process_dxf_file(message: types.Message):
    if not coefficients:
        await message.answer("‚ö†Ô∏è –°–Ω–∞—á–∞–ª–∞ –≤–≤–µ–¥–∏—Ç–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã!")
        return
    if cutting_cost is None:
        await message.answer("‚ö†Ô∏è –°–Ω–∞—á–∞–ª–∞ –≤–≤–µ–¥–∏—Ç–µ —Å—Ç–æ–∏–º–æ—Å—Ç—å —Ä–µ–∑–∞!")
        return

    document = message.document
    if not document.file_name.endswith(".dxf"):
        await message.answer("‚ùå –§–∞–π–ª –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ —Ñ–æ—Ä–º–∞—Ç–µ DXF!")
        return

    file_path = f"downloads/{document.file_name}"
    os.makedirs("downloads", exist_ok=True)

    try:
        file_info = await bot.get_file(document.file_id)
        await bot.download_file(file_info.file_path, file_path)
        await message.answer("‚úÖ –§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω, –Ω–∞—á–∏–Ω–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É...")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞.")
        return

    try:
        doc = ezdxf.readfile(file_path)
        msp = doc.modelspace()
        lengths = {"LINE": 0, "POLYLINE": 0, "ARC": 0, "CIRCLE": 0, "SPLINE": 0}

        for entity in msp:
            dxftype = entity.dxftype()
            if dxftype == "LINE":
                lengths["LINE"] += (Vec3(entity.dxf.start) - Vec3(entity.dxf.end)).magnitude
            elif dxftype in {"LWPOLYLINE", "POLYLINE"}:
                points = [Vec3(p[0], p[1]) for p in entity.get_points()]
                lengths["POLYLINE"] += sum((p1 - p2).magnitude for p1, p2 in zip(points, points[1:]))
            elif dxftype == "ARC":
                radius = entity.dxf.radius
                angle_diff = math.radians((entity.dxf.end_angle - entity.dxf.start_angle) % 360)
                lengths["ARC"] += angle_diff * radius
            elif dxftype == "CIRCLE":
                lengths["CIRCLE"] += 2 * math.pi * entity.dxf.radius
            elif dxftype == "SPLINE":
                spline_points = list(entity.flattening(distance=0.1))
                lengths["SPLINE"] += sum((Vec3(p1) - Vec3(p2)).magnitude for p1, p2 in zip(spline_points, spline_points[1:]))

        total_length = sum(lengths.values())
        total_adjusted = sum(lengths[key] * coefficients[key] for key in lengths)
        total_cutting_cost = total_adjusted * cutting_cost

        result_text = (
            f"üìä *–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞—Å—á—ë—Ç–∞:*\n"
            f"üîπ –î–ª–∏–Ω–∞ –ª–∏–Ω–∏–π: {lengths['LINE']:.2f} –º–º\n"
            f"üîπ –î–ª–∏–Ω–∞ –ø–æ–ª–∏–ª–∏–Ω–∏–π: {lengths['POLYLINE']:.2f} –º–º\n"
            f"üîπ –î–ª–∏–Ω–∞ –¥—É–≥: {lengths['ARC']:.2f} –º–º\n"
            f"üîπ –î–ª–∏–Ω–∞ –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–µ–π: {lengths['CIRCLE']:.2f} –º–º\n"
            f"üîπ –î–ª–∏–Ω–∞ —Å–ø–ª–∞–π–Ω–æ–≤: {lengths['SPLINE']:.2f} –º–º\n"
            f"üìå *–û–±—â–∞—è –¥–ª–∏–Ω–∞: {total_length:.2f} –º–º*\n\n"
            f"üí∞ *–°—Ç–æ–∏–º–æ—Å—Ç—å —Ä–µ–∑–∞: {total_cutting_cost:.2f}*"
        )

        await message.answer(result_text, parse_mode="Markdown")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ DXF: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–∞–π–ª–∞.")

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–∑—ã–≤–∞
@dp.message(lambda message: message.text == "üìù –û—Å—Ç–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤")
async def ask_for_feedback(message: types.Message):
    await message.answer("üí¨ –ù–∞–ø–∏—à–∏—Ç–µ –≤–∞—à –æ—Ç–∑—ã–≤. –ú—ã –±—É–¥–µ–º —Ä–∞–¥—ã —É—Å–ª—ã—à–∞—Ç—å –≤–∞—à–µ –º–Ω–µ–Ω–∏–µ!")

@dp.message(lambda message: message.from_user.id in registered_users and message.text and message.text != "üìù –û—Å—Ç–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤")
async def handle_feedback(message: types.Message):
    feedback = message.text
    user_id = message.from_user.id
    user = registered_users.get(user_id)

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–∑—ã–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É
    for admin_id in ADMIN_IDS:
        await bot.send_message(admin_id, f"üìù –ù–æ–≤—ã–π –æ—Ç–∑—ã–≤ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}:\n{feedback}")

    await message.answer("–°–ø–∞—Å–∏–±–æ –∑–∞ –≤–∞—à –æ—Ç–∑—ã–≤! –û–Ω –±—ã–ª –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")

async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.create_task(main())
